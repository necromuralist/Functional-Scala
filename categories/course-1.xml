<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Functional Scala (Posts about course 1)</title><link>https://necromuralist.github.io/Functional-Scala/</link><description></description><atom:link href="https://necromuralist.github.io/Functional-Scala/categories/course-1.xml" rel="self" type="application/rss+xml"></atom:link><language>en</language><copyright>Contents © 2019 &lt;a href="mailto:necromuralist@protonmail.com"&gt;Cloistered Monkey&lt;/a&gt; </copyright><lastBuildDate>Sun, 15 Dec 2019 03:23:26 GMT</lastBuildDate><generator>Nikola (getnikola.com)</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Recursion</title><link>https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/</link><dc:creator>Cloistered Monkey</dc:creator><description>&lt;div id="table-of-contents"&gt;
&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;div id="text-table-of-contents"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org3e45d89"&gt;Begin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org3bb9c97"&gt;Middle&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org83afb1a"&gt;Exercise 1: Pascal’s Triangle&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org4b0ea9a"&gt;Pascal Tester&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org3e82d44"&gt;Naively Recursive Version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org3a420d3"&gt;Tail-Recursion Version&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org69faa94"&gt;Exercise 2: Parentheses Balancing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#org9139507"&gt;Exercise 3: Counting Change&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/#orgb26bd85"&gt;End&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3e45d89" class="outline-2"&gt;
&lt;h2 id="org3e45d89"&gt;Begin&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3e45d89"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;import scala.collection.mutable.Stack
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3bb9c97" class="outline-2"&gt;
&lt;h2 id="org3bb9c97"&gt;Middle&lt;/h2&gt;
&lt;div class="outline-text-2" id="text-org3bb9c97"&gt;
&lt;/div&gt;
&lt;div id="outline-container-org83afb1a" class="outline-3"&gt;
&lt;h3 id="org83afb1a"&gt;Exercise 1: Pascal’s Triangle&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org83afb1a"&gt;
&lt;p&gt;
The following pattern of numbers is called Pascal’s triangle.
&lt;/p&gt;

&lt;pre class="example"&gt;
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
&lt;/pre&gt;

&lt;p&gt;
The numbers at the edge of the triangle are all 1, and each number inside the triangle is the sum of the two numbers above it. Write a function that computes the elements of Pascal’s triangle by means of a recursive process.
&lt;/p&gt;

&lt;p&gt;
Do this exercise by implementing the pascal function in Main.scala, which takes a column c and a row r, counting from 0 and returns the number at that spot in the triangle. For example, &lt;code&gt;pascal(0,2)=1&lt;/code&gt;, &lt;code&gt;pascal(1,2)=2&lt;/code&gt;, and &lt;code&gt;pascal(1,3)=3&lt;/code&gt;.
&lt;/p&gt;
&lt;/div&gt;
&lt;div id="outline-container-org4b0ea9a" class="outline-4"&gt;
&lt;h4 id="org4b0ea9a"&gt;Pascal Tester&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org4b0ea9a"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def test_pascal(function_under_test: (Int, Int) =&amp;gt; Int): Unit = {  
  assert(function_under_test(0, 0) == 1)
  try {
    function_under_test(1, 0)
    throw new AssertionError
  } catch {
    case e: IllegalArgumentException =&amp;gt; println("Passed pascal(0, 1)")
  }

  try {
    function_under_test(-2, -1)
    throw new AssertionError
  } catch {
    case e: IllegalArgumentException =&amp;gt; println("Passed pascal(0, -1)")
  }

  try {
    function_under_test(-1, 0)
    throw new AssertionError
  } catch {
    case e: IllegalArgumentException =&amp;gt; println("Passed pascal(-1, 0)")
  }

  assert(function_under_test(0, 2) == 1)
  assert(function_under_test(1, 2) == 2)
  assert(function_under_test(1, 3) == 3)
  assert(function_under_test(3, 5) == 10)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-org3e82d44" class="outline-4"&gt;
&lt;h4 id="org3e82d44"&gt;Naively Recursive Version&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3e82d44"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def pascal_1(c: Int, r: Int): Int = c match {
      case 0 =&amp;gt; {
	require(c &amp;lt;= r)
	1
      }
      case _ =&amp;gt; {
	require(c &amp;lt;= r)
	require(c &amp;gt;= 0)
	pascal(c - 1, r) * (r + 1 - c)/c
      }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test_pascal(pascal_1)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
6 - 7a489557-893d-47dd-9459-92a57291515b

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org3a420d3" class="outline-4"&gt;
&lt;h4 id="org3a420d3"&gt;Tail-Recursion Version&lt;/h4&gt;
&lt;div class="outline-text-4" id="text-org3a420d3"&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def pascal(c: Int, r: Int): Int = {
    @annotation.tailrec
    def pascal_accumulated(column: Int, row: Int, accumulator: Int): Int = column match{
      case 0 =&amp;gt; {
	require(column &amp;lt;= row)
	accumulator
      }
      case _ =&amp;gt; {
	require(column &amp;lt;= row)
	require(column &amp;gt;= 0)
	pascal_accumulated(column - 1, row, accumulator * (row + 1 - column)/column)
      }
    } // pascal_accumulated
    pascal_accumulated(c, r, 1)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test_pascal(pascal)
&lt;/pre&gt;&lt;/div&gt;

&lt;pre class="example"&gt;
8 - 9656bc37-fd80-4110-9d6f-f7e77b546f8f

&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org69faa94" class="outline-3"&gt;
&lt;h3 id="org69faa94"&gt;Exercise 2: Parentheses Balancing&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org69faa94"&gt;
&lt;p&gt;
Write a recursive function which verifies the balancing of parentheses in a string, which we represent as a List[Char] not a String. For example, the function should return true for the following strings:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;(if (zero? x) max (/ 1 x))&lt;/li&gt;
&lt;li&gt;I told him (that it’s not (yet) done). (But he wasn’t listening)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The function should return false for the following strings:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;:-)&lt;/li&gt;
&lt;li&gt;())(&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
The last example shows that it’s not enough to verify that a string contains the same number of opening and closing parentheses.
&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def test_balance(function_under_test: (List[Char]) =&amp;gt; Boolean): Unit = {
    assert(function_under_test("".toList))
    println("Passed Empty List")
    assert(!function_under_test("(".toList))
    println("Passed left bracket only")
    assert(balance("(if (zero? x) max (/ 1 x))".toList))
    assert(balance("I told him (that it's not (yet) done).\n(But he wasn't listening)".toList))
    assert(!balance(":-)".toList))
    assert(!balance("())(".toList))
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
Do this exercise by implementing the balance function in Main.scala. Its signature is as follows:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def balance(chars: List[Char]): Boolean = {
  @annotation.tailrec
  def balance_accumulated(chars: List[Char], lefts: Int, rights: Int): Boolean = chars match {
    case Nil =&amp;gt; lefts == rights
    case head :: tail =&amp;gt; {
      val left = if (head == '(') 1 else 0
      val right = if (head == ')') 1 else 0
      if (right + rights &amp;gt; left + lefts)
	false
      else
	balance_accumulated(tail, lefts + left, rights + right)

    }
  } // balance_accumulated
  balance_accumulated(chars, 0, 0)
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
There are three methods on List[Char] that are useful for this exercise:
&lt;/p&gt;

&lt;ul class="org-ul"&gt;
&lt;li&gt;chars.isEmpty: Boolean returns whether a list is empty&lt;/li&gt;
&lt;li&gt;chars.head: Char returns the first element of the list&lt;/li&gt;
&lt;li&gt;chars.tail: List[Char] returns the list without the first element&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;
Hint: you can define an inner function if you need to pass extra parameters to your function.
&lt;/p&gt;

&lt;p&gt;
Testing: You can use the toList method to convert from a String to aList[Char]: e.g. "(just an) example".toList.
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;test_balance(balance)
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div id="outline-container-org9139507" class="outline-3"&gt;
&lt;h3 id="org9139507"&gt;Exercise 3: Counting Change&lt;/h3&gt;
&lt;div class="outline-text-3" id="text-org9139507"&gt;
&lt;p&gt;
Write a recursive function that counts how many different ways you can make change for an amount, given a list of coin denominations. For example, there are 3 ways to give change for 4 if you have coins with denomination 1 and 2: 1+1+1+1, 1+1+2, 2+2.
&lt;/p&gt;

&lt;p&gt;
Do this exercise by implementing the countChange function inMain.scala. This function takes an amount to change, and a list of unique denominations for the coins. Its signature is as follows:
&lt;/p&gt;

&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="n"&gt;countChange&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;money&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;coins&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;List&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;])&lt;/span&gt;&lt;span class="k"&gt;:&lt;/span&gt; &lt;span class="kt"&gt;Int&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
Once again, you can make use of functions isEmpty, head and tail on the list of integers coins.
&lt;/p&gt;

&lt;p&gt;
&lt;b&gt;&lt;b&gt;Hint&lt;/b&gt;&lt;/b&gt;: Think of the degenerate cases. How many ways can you give change for 0 CHF(swiss money)? How many ways can you give change for &amp;gt;0 CHF, if you have no coins?
&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id="outline-container-orgb26bd85" class="outline-2"&gt;
&lt;h2 id="orgb26bd85"&gt;End&lt;/h2&gt;
&lt;/div&gt;</description><category>course 1</category><guid>https://necromuralist.github.io/Functional-Scala/posts/course-1/recursion/</guid><pubDate>Sun, 08 Dec 2019 03:49:38 GMT</pubDate></item></channel></rss>